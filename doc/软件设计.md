<link rel="stylesheet" type="text/css" href="base.css">

软件设计
====== 
## 开发组织
### 开发环境
上位机由C# wpf开发，基于.net framework 3.5以上，当前使用visual studio 2022  
文件编码为utf-8无bom；制表符缩进，长度为4；换行为\n  
### 文件组织  
<pre>
<b>com_mc</b>: C# wpf代码
	<b>app</b>: 应用代码
		cm_plugin.cs		实现插件的调用，默认处理对象的实现  
		tool.cs			通用工具
		frame_sync.cs		帧同步库
		record.cs		日志回放部分
		config.cs		软件配置的实现
	<b>mc</b>: 测控部分
		com_mc.cs		传感对象和指令对象的实现，界面无关，协议无关
		com_mc_gui.cs		控制控件的实现，与主程序无关  
		para.cs			参数变量的定义
		prot.cs			动态协议的定义
		sync.cs			帧同步配置定义
	<b>dlg</b>: 对话框文件
		help.xaml		帮助对话框
		replay_window.xaml	回放对话框
		prot_cfg.xaml	协议编辑对话框
	<b>pic</b>: 存放软件引用的图片  
	state_dis.cs：		测控逻辑的适配，初始化曲线和状态的显示、初始化控制控件
	MainWindow:		主程序界面
<b>cm_plugin</b>: 示例插件代码
<b>doc</b>:	项目文档
<b>image</b>:  项目图片
<b>out</b>： 存放输出文件
	<b>cfgs</b>： 示例协议配置
	<b>data</b>： 示例日志存储
	config.txt ： 默认配置文件，在运行时定义通用上位机的界面和协议
	cm_cfgs.txt ： 默认可选多种配置的配置文件
	com_mc.exe : 生成的可执行文件  
	cm_plugin.dll : 示例插件dll
	*.dll : 程序依赖的动态库
<b>com_mc.sln</b>：	项目解决方案入口  
</pre>
## 软件部署  
生成文件为com_mc.exe，默认配置文件为config.txt。一般只需这两个文件就可以执行，非常便携。  
具体部署规则参考[使用说明.md](使用说明.md)

## 主体结构  
### 测控概念结构
测控概念主要由几个大的部分组成：测控通信、动态协议、数据源、日志记录与回放。概念图如下：
![image](draft/概念结构.drawio.png)  

### 测控部分
可复用的测控模块不包含应用部分，具体功能为：
1. 测量量字典：通过唯一的字符串名称索引测量变量
2. 指令字典：通过唯一的字符串名称索引指令
3. 指令界面定义：仅定义下发指令的控件，按钮、开关等
模块代码放在两个文件中：**com_mc.cs，com_mc_gui.cs**

![image](draft/设计-可复用测控结构.drawio.png)  
### 动态协议部分
见[动态协议设计.md](动态协议设计.md)
### 数据源部分
软件支持多种数据源使用统一的接口实现数据输入，在运行时可选不同的数据源。  
1. 串口  
串口数据源初始化时可列出系统中的所有串口名称，加入数据源列表  
串口的模式仅支持无校验，8bit数据，1bit停止。波特率通过配置文件配置，软件运行时不可修改  
1. udp  
udp数据源通过配置文件指定本地和远程地址  
1. 回放  
通过日志回放模块虚拟数据源，触发软件的日志回放响应

数据源层通过抽象DataSrc类的静态域组织，List<DataSrc> dslist记录当前系统中的数据源列表，factory函数通过反射创建数据源，数据源的类命名规则为：cslib.DataSrc_开头。
数据源的对外接口：
1. 创建：构造函数传入void RX_CB(byte[] b)的回调函数，作为接收回调函数
2. 打开：open函数
3. 关闭：close函数
4. 获取此数据源内部端口名列表：get_names函数，例如获取系统中所有串口名
5. 发送：send_data函数
只需实现上述接口即可实现一个新的数据源。
### com_mc实现结构
程序的模块：  
> - **MainWindow**: 组织界面逻辑，实现曲线控制，出10Hz定时器，调用处理流程  
> - **com_mc**：
	定义测控概念中的测量类：DataDes（数据描述），实现数据结构和协议处理
	定义测控概念中的控制指令类：CmdDes（指令描述） 
	定义通用测控类MC_Prot，组织测量对象字典（dset）、控制对象字典（cmds）
> - **com_mc_gui**: 定义测控概念中控制指令的界面显示类，实现各种形式的控制指令界面实现；测量方面，使用通用控件，所以没有定义。  
> - **state_dis**: 作为MainWindow的部分类实现，实现测控应用的逻辑：  
	组织测控概念中的对象，包括日志、界面中的曲线、测量控件等
	实现测量控件的构造
	实现控制控件的构造
	实现菜单控件的构造
	构造定时器，查询插件
	实现软件控制指令
	实现数据收发的处理

![image](draft/动态协议实现结构.png)  
### 插件机制
插件的接口包括：  
1. tx_cb: 向设备发送的回调函数（插件发送给主程序，主程序向设备发送）  
2. rx_cb: 上位机接收设备信息的回调函数（插件发送给主程序，主程序处理）  
3. rx_bin_cb: 上位机接收设备信息的回调函数（插件发送给主程序，主程序处理）  
4. ini: 初始化，注册回调函数  
5. fromJson: 从配置初始化，在ini之后  
6. send_cmd: 主程序发送指令（主程序发送给插件）  
7. rx_fun: 接收数据函数（主程序接收到设备的数据）  
8. so_poll_100: 周期调用,100Hz  
## 主体流程
数据上下行总体流程图：
![image](draft/数据流程.png)  
### 上行流程
程序的调用源：
1. MainWindow的10Hz定时器，ui线程  
	曲线的添加删除  
	测量对象是否有数据的刷新：使用测量对象的update_dis回调  
控制对象的显示是引用了测量对象，所以测量对象的是否有数据刷新，以及数据状态刷新后，控制对象控件也就实现了刷新  
2. 用户的操作输入，ui线程  
	控制部分被动接受ui的调用，实现指令下发  
3. MainWindow的100Hz定时器threadTimer回调：OnTimedEvent，独立线程  
	用于调用插件的100Hz处理  
4. 数据源的接收线程  
	测量部分被动接收:  
> - 通过state_dis的rx_fun函数接收原始数据的输入  
> - 输入插件的rx_fun，经过插件的帧同步，输出rx_pack回调  
> - 插件的回调函数中使用Invoke，通过主线程调用记录和协议处理：MC_Prot的pro
> - 二进制的情况：调用prot_root的处理函数，接下来递归调用各协议域的处理  
> - 文本的情况：构造协议名，在协议字典textline_dict中查询协议，按列处理  
	通过PD_Node的set_para_val函数，调用ParaValue_Val的set_val函数，实现赋值  
	通过update_cb实现界面刷新，包括显示和曲线添加点  
### 下行流程
下行过程一般由界面发起，只能配置文本指令。通过state_dis模块检查是否有软件配置指令，然后调用处理插件的send_cmd函数，由插件进行协议转换，若下发二进制协议，则在插件中转换为对应的二进制包，调用插件回调函数，通过当前数据源实现发送。
### 配置流程
## 日志记录与回放
### 日志分类
软件可将上行数据保存成文件，形成日志记录。其中文本的数据存放在带时间戳的文本文件中，二进制数据存放在cmlog格式混合日志文件的信道1中
日志文件分为3种：无时间戳文本，带时间戳文本，cmlog混合日志。
> - **原始数据**
	无时间戳的数据直接存储，软件不会记录这种格式，但可以回放这种格式，以最快的速度加载所有数据。所以曲线中的数据没有横坐标，需要在软件中通过指令配置横坐标的索引数据。 
> - **带时间戳文本**
	在每个文本协议行首加入"mmss.fff	"格式的时间戳（分秒.毫秒），tab分割。软件记录文本数据时使用此格式。
> - **cmlog混合日志**
	软件特有的日志格式，可由其他应用程序产生，通用测控软件读取。日志具有多个虚拟信道，可分别存储不同格式的日志。每个存储帧具有ms时间戳
### cmlog日志格式
cmlog为二进制外包装，内部为数据流，可存储任意结构的数据。分数据帧存储，数据帧内具有6Byte头部记录存储帧长，虚拟信道号、帧类型信息，用以从文件中解析各信道的数据流。
![image](draft/设计-cmlog结构.drawio.png)  
数据头格式如下，数据帧数据载荷最大长度65535字节，最大16个虚拟信道
```C++
#pragma pack(1)
typedef struct //8 Byte
{
	u8 syn; 	//0xA0 同步字
	u8 type		:1; //类型，0文本，1二进制
	u8 res		:3; //
	u8 vir		:4; //虚拟信道号（高4bit）
	u16 len; 	//本行数据长度
	u32 ms; 	//距离文件起始的ms数
} CMLOG_ROWHEAD; //混合日志行头
#pragma pack()
```
文件名中包含了本文件的记录起始时间，精确到秒。文件内部的记录帧只需记录在1小时以内的ms数。
### 记录流程
为了能够回放，日志的记录需要存储时间戳。而未经帧同步的数据难以加入时间戳，若按接收包加，则文本行可能被截断。所以日志的记录应该选在帧同步后  
文本格式的记录使用LogFile rec_text，二进制记录使用cmlog格式，BinDataFile rec_bin_file。
在state_dis.cs中，rx_pack函数里，根据记录模式rec_mod进行记录。
### 回放结构
回放控制类DataSrc_replay是一个数据源类。
> - open函数：分类打开数据文件，初步处理原始数据，形成易于访问的数据缓存
> - set_replay_pos函数设置回放位置
> - 支持suspend、resume、stop暂停、恢复、终止。

打开回放数据源后，会通过线程池提交回放线程任务。
回放数据源在打开时，加载文件的所有内容，并根据文件的类型进行解析，将时间戳、行信息存放在line_ms_list等变量中，用以回放。
![image](draft/设计-回放结构.drawio.png)  
其中回放的数据缓存为：
``` cs
byte[] 		org_data; //cmlog的原始数据记录
List<int> 	line_ms_list; //每一行的ms间戳
List<string> 	data_lines; //文本格回放数据缓存，若是二进制，则为hex显示数据
List<CMLOG_HEAD> line_cmlog_list; //cmlog的每一行的头
List<byte[]>	 bin_lines; //回放数据存(二进制)
```
### 回放流程
回放流程在回放线程中，通过状态机实现，状态变量为：state，0终止，1暂停，2回放，3单步
![image](draft/设计-回放状态机.drawio.png)  
回放线程调用**try_to_play**函数实现回放，**try_to_play**内部会判断当前回放行的ms数与回放时刻，决定是否回放，一次调用会回放所有小于回放时刻的行。
**replay_run_1_frame**为回放一帧数据的函数。
回放过程中，可通过**set_replay_pos**设置回放位置，设置单位为行号。

回放的时间控制：
回放可选择不同的速度，回放原理是比较当前回放时刻（**replay_ms**）与各回放帧的ms时间戳，而**replay_ms**并不是以正常的时间速度增加的。
通过上次回放时间**pre_replay_ms**与当前时间的差，确定真实时间间隔，然后这个间隔乘以回放速度比例，得到回放时间增量，加到**replay_ms**上。
### 指定变量输出
回放数据的导出可通过回放的数据缓存，以及回放起止位置变量轻易的实现，但要实现指定变量的导出，就必须进行协议解析，完成解析后按指定的变量实现输出。
指定变量输出功能在回放对话框中以导出变量csv实现，回放对话框界面上会显示系统中的所有变量，通过CheckBox实现变量的选择，在**export_csv**函数中实现导出功能。
**export_csv**的流程如下：
![image](draft/设计-指定变量csv流程.drawio.png)  
输出时，首先输出csv行首，为每个变量的名称。且固定第一列为时间戳，单位ms。

## 动态协议编辑UI
动态协议的可视化通过一个对话框实现，对话框中通过DataGrid显示参数列表、协议列表、协议域根节点列表。并通过一个winform控件PropertyGrid实现具体对象的信息显示和编辑。
为了显示具体对象的属性描述，UI部分对动态协议部分类进行了装饰，建立了继承路径一致的显示协议类：
